package com.workflow.examples.jdbc;

import com.workflow.context.WorkflowContext;
import com.workflow.task.JdbcCallableTask;
import com.workflow.task.JdbcQueryTask;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.sql.DataSource;
import lombok.extern.slf4j.Slf4j;
import org.h2.jdbcx.JdbcDataSource;

/**
 * Comprehensive examples demonstrating JdbcCallableTask usage with an in-memory H2 database.
 *
 * <p>JdbcCallableTask executes database stored procedures and functions, supporting:
 *
 * <ul>
 *   <li>IN parameters (input values)
 *   <li>OUT parameters (output values)
 *   <li>INOUT parameters (both input and output)
 *   <li>Return values from functions
 *   <li>Multiple result sets from procedures
 * </ul>
 *
 * <p>Examples from simple to complex:
 *
 * <ul>
 *   <li>Example 1: Simple procedure with IN parameters
 *   <li>Example 2: Procedure with - OUT parameters
 *   <li>Example 3: Function with return value
 *   <li>Example 4: Procedure with INOUT parameters
 *   <li>Example 5: Procedure returning result sets
 *   <li>Example 6: Complex procedure with mixed parameters
 * </ul>
 */
@Slf4j
public class JdbcCallableTaskExample {

  public static final String CALL_UPDATE_BALANCE = "{call update_balance(?, ?)}";
  public static final String CALL_CALCULATE_INTEREST = "{? = call calculate_interest(?, ?, ?)}";
  public static final String RESULT = "result";
  public static final String ACCOUNT_1 = "Account 1";
  public static final String ACCOUNT_2 = "Account 2";
  public static final String CALL_TRANSFER_MONEY = "{call transfer_money(?, ?, ?)}";
  private final DataSource dataSource;

  public JdbcCallableTaskExample() throws SQLException {
    this.dataSource = createDataSource();
    initializeDatabase();
  }

  /** Creates an H2 in-memory database data source. */
  private DataSource createDataSource() {
    JdbcDataSource ds = new JdbcDataSource();
    ds.setURL("jdbc:h2:mem:callable_db;DB_CLOSE_DELAY=-1;MODE=PostgreSQL");
    ds.setUser("sa");
    ds.setPassword("");
    return ds;
  }

  /** Initializes the database with tables and stored procedures/functions. */
  private void initializeDatabase() throws SQLException {
    try (Connection conn = dataSource.getConnection();
        Statement stmt = conn.createStatement()) {

      // Create accounts table
      stmt.execute(
          "CREATE TABLE IF NOT EXISTS accounts ("
              + "id INT PRIMARY KEY, "
              + "account_number VARCHAR(20) UNIQUE, "
              + "balance DECIMAL(10,2), "
              + "account_type VARCHAR(20), "
              + "status VARCHAR(20) DEFAULT 'ACTIVE'"
              + ")");

      // Create transactions table
      stmt.execute(
          "CREATE TABLE IF NOT EXISTS account_transactions ("
              + "id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
              + "account_id INT, "
              + "amount DECIMAL(10,2), "
              + "transaction_type VARCHAR(20), "
              + "transaction_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP"
              + ")");

      // Insert sample accounts
      stmt.execute("INSERT INTO accounts VALUES (1, 'ACC001', 1000.00, 'CHECKING', 'ACTIVE')");
      stmt.execute("INSERT INTO accounts VALUES (2, 'ACC002', 5000.00, 'SAVINGS', 'ACTIVE')");
      stmt.execute("INSERT INTO accounts VALUES (3, 'ACC003', 250.00, 'CHECKING', 'ACTIVE')");

      // Create stored procedures and functions
      createStoredProcedures(conn);

      log.info("Database initialized with tables and stored procedures");
    } catch (SQLException e) {
      log.error("Failed to initialize database", e);
      throw e;
    }
  }

  /** Creates stored procedures and functions for examples. */
  private void createStoredProcedures(Connection conn) throws SQLException {
    try (Statement stmt = conn.createStatement()) {

      // Procedure 1: Update account balance (IN parameters only)
      stmt.execute(
          "CREATE ALIAS IF NOT EXISTS update_balance AS $$ "
              + "void updateBalance(java.sql.Connection conn, int accountId, double amount) throws SQLException { "
              + "  java.sql.PreparedStatement ps = conn.prepareStatement("
              + "    \"UPDATE accounts SET balance = balance + ? WHERE id = ?\"); "
              + "  ps.setDouble(1, amount); "
              + "  ps.setInt(2, accountId); "
              + "  ps.executeUpdate(); "
              + "} $$");

      // Procedure 2: Get account info (IN and OUT parameters)
      // Procedure 2: Get account info (IN and OUT parameters)
      stmt.execute(
          "CREATE ALIAS IF NOT EXISTS get_account_info AS $$ "
              + "@CODE "
              // Change SQLException to java.sql.SQLException below
              + "void getAccountInfo(java.sql.Connection conn, int accountId, "
              + "  java.sql.ResultSet[] outBalance, java.sql.ResultSet[] outType) throws java.sql.SQLException { "
              + "  java.sql.PreparedStatement ps = conn.prepareStatement("
              + "    \"SELECT balance, account_type FROM accounts WHERE id = ?\"); "
              + "  ps.setInt(1, accountId); "
              + "  java.sql.ResultSet rs = ps.executeQuery(); "
              + "  if (rs.next()) { "
              + "    outBalance[0] = rs; "
              + "  } "
              + "} "
              + "$$");

      // Function: Calculate interest
      // Inside your initializeDatabase / createStoredProcedures method
      stmt.execute(
          "CREATE ALIAS IF NOT EXISTS calculate_interest AS $$ "
              + "double calculateInterest(double balance, double rate, int months) { "
              + "  return balance * (rate / 100.0) * (months / 12.0); "
              + "} $$");

      // Procedure 3: Transfer money with validation
      stmt.execute(
          "CREATE ALIAS IF NOT EXISTS transfer_money AS $$ "
              + "void transferMoney(java.sql.Connection conn, int fromAccount, int toAccount, double amount) "
              + "throws java.sql.SQLException { "
              + "  java.sql.PreparedStatement ps1 = conn.prepareStatement("
              + "    \"UPDATE accounts SET balance = balance - ? WHERE id = ?\"); "
              + "  ps1.setDouble(1, amount); "
              + "  ps1.setInt(2, fromAccount); "
              + "  ps1.executeUpdate(); "
              + "  "
              + "  java.sql.PreparedStatement ps2 = conn.prepareStatement("
              + "    \"UPDATE accounts SET balance = balance + ? WHERE id = ?\"); "
              + "  ps2.setDouble(1, amount); "
              + "  ps2.setInt(2, toAccount); "
              + "  ps2.executeUpdate(); "
              + "  "
              + "  java.sql.PreparedStatement ps3 = conn.prepareStatement("
              + "    \"INSERT INTO account_transactions (account_id, amount, transaction_type) VALUES (?, ?, ?)\"); "
              + "  ps3.setInt(1, fromAccount); "
              + "  ps3.setDouble(2, -amount); "
              + "  ps3.setString(3, \"TRANSFER_OUT\"); "
              + "  ps3.executeUpdate(); "
              + "  "
              + "  ps3.setInt(1, toAccount); "
              + "  ps3.setDouble(2, amount); "
              + "  ps3.setString(3, \"TRANSFER_IN\"); "
              + "  ps3.executeUpdate(); "
              + "} $$");
    }
  }

  /**
   * Example 1: Simple procedure with IN parameters only. Demonstrates calling a procedure that
   * modifies data.
   */
  public void example1SimpleProcedureWithInParams() {
    log.info("\n=== Example 1: Simple Procedure with IN Parameters ===");

    // Check initial balance
    verifyAccountBalance(1, "Before");

    // Call procedure to add $500 to account 1
    Map<Integer, Object> inParams = new HashMap<>();
    inParams.put(1, 1); // accountId
    inParams.put(2, 500.0); // amount

    JdbcCallableTask task =
        JdbcCallableTask.builder()
            .dataSource(dataSource)
            .call(CALL_UPDATE_BALANCE)
            .inParameters(inParams)
            .build();

    WorkflowContext context = new WorkflowContext();
    task.execute(context);

    log.info("Procedure executed successfully");

    // Verify updated balance
    verifyAccountBalance(1, "After");
  }

  /**
   * Example 2: Function with return value. Demonstrates calling a function that returns a
   * calculated value.
   */
  public void example2FunctionWithReturnValue() {
    log.info("\n=== Example 2: Function with Return Value ===");

    // Calculate interest on $10,000 at 5% for 24 months
    Map<Integer, Object> inParams = new HashMap<>();
    inParams.put(2, 10000.0); // balance
    inParams.put(3, 5.0); // rate (5%)
    inParams.put(4, 24); // months

    // Register return value as OUT parameter at position 1
    Map<Integer, Integer> outParams = new HashMap<>();
    outParams.put(1, Types.DOUBLE); // Return value position

    JdbcCallableTask task =
        JdbcCallableTask.builder()
            .dataSource(dataSource)
            .call(CALL_CALCULATE_INTEREST)
            .inParameters(inParams)
            .outParameters(outParams)
            .writingOutValuesTo(RESULT)
            .build();

    WorkflowContext context = new WorkflowContext();
    task.execute(context);

    @SuppressWarnings("unchecked")
    Map<Integer, Object> outValues = (Map<Integer, Object>) context.get(RESULT);
    Double interest = (Double) outValues.get(1);

    log.info("Interest calculation:");
    log.info("  Principal: $10,000");
    log.info("  Rate: 5%");
    log.info("  Period: 24 months");
    log.info("  Interest: ${}", String.format("%.2f", interest));
  }

  /**
   * Example 3: Procedure with multiple operations (money transfer). Demonstrates a complex
   * procedure that performs multiple database operations.
   */
  public void example3ComplexTransferProcedure() {
    log.info("\n=== Example 3: Complex Transfer Procedure ===");

    log.info("Account balances before transfer:");
    verifyAccountBalance(1, ACCOUNT_1);
    verifyAccountBalance(2, ACCOUNT_2);

    // Transfer $300 from account 1 to account 2
    Map<Integer, Object> inParams = new HashMap<>();
    inParams.put(1, 1); // fromAccount
    inParams.put(2, 2); // toAccount
    inParams.put(3, 300.0); // amount

    JdbcCallableTask task =
        JdbcCallableTask.builder()
            .dataSource(dataSource)
            .call(CALL_TRANSFER_MONEY)
            .inParameters(inParams)
            .build();

    WorkflowContext context = new WorkflowContext();
    task.execute(context);

    log.info("\nTransfer completed successfully");

    log.info("\nAccount balances after transfer:");
    verifyAccountBalance(1, ACCOUNT_1);
    verifyAccountBalance(2, ACCOUNT_2);

    // Verify transaction records
    verifyTransactionHistory();
  }

  /**
   * Example 4: Dynamic callable statement from context. Demonstrates reading call statement and
   * parameters from workflow context.
   */
  public void example4DynamicCallable() {
    log.info("\n=== Example 4: Dynamic Callable from Context ===");

    JdbcCallableTask task =
        JdbcCallableTask.builder()
            .dataSource(dataSource)
            .readingCallFrom("callStatement")
            .readingInParametersFrom("inParams")
            .readingOutParametersFrom("outParams")
            .writingOutValuesTo("outValues")
            .build();

    WorkflowContext context = new WorkflowContext();

    // Scenario: Calculate interest dynamically
    Map<Integer, Object> inParams = new HashMap<>();
    inParams.put(2, 25000.0); // balance
    inParams.put(3, 3.5); // rate
    inParams.put(4, 36); // months

    Map<Integer, Integer> outParams = new HashMap<>();
    outParams.put(1, Types.DOUBLE);

    context.put("callStatement", CALL_CALCULATE_INTEREST);
    context.put("inParams", inParams);
    context.put("outParams", outParams);

    task.execute(context);

    @SuppressWarnings("unchecked")
    Map<Integer, Object> outValues = (Map<Integer, Object>) context.get("outValues");
    Double interest = (Double) outValues.get(1);

    log.info("Dynamic interest calculation result: ${}", String.format("%.2f", interest));
  }

  /**
   * Example 5: Batch account operations with multiple procedure calls. Demonstrates orchestrating
   * multiple stored procedure calls in a workflow.
   */
  public void example5BatchOperations() {
    log.info("\n=== Example 5: Batch Operations with Multiple Procedures ===");

    log.info("Initial balances:");
    verifyAccountBalance(1, ACCOUNT_1);
    verifyAccountBalance(2, ACCOUNT_2);
    verifyAccountBalance(3, "Account 3");

    // Operation 1: Deposit to account 1
    Map<Integer, Object> deposit1 = new HashMap<>();
    deposit1.put(1, 1);
    deposit1.put(2, 200.0);

    JdbcCallableTask depositTask1 =
        JdbcCallableTask.builder()
            .dataSource(dataSource)
            .call(CALL_UPDATE_BALANCE)
            .inParameters(deposit1)
            .build();

    // Operation 2: Deposit to account 3
    Map<Integer, Object> deposit2 = new HashMap<>();
    deposit2.put(1, 3);
    deposit2.put(2, 150.0);

    JdbcCallableTask depositTask2 =
        JdbcCallableTask.builder()
            .dataSource(dataSource)
            .call(CALL_UPDATE_BALANCE)
            .inParameters(deposit2)
            .build();

    // Operation 3: Calculate interest for account 2
    Map<Integer, Object> interestCalc = new HashMap<>();
    interestCalc.put(2, 5000.0); // Current balance
    interestCalc.put(3, 4.0); // 4% rate
    interestCalc.put(4, 12); // 12 months

    Map<Integer, Integer> outParams = new HashMap<>();
    outParams.put(1, Types.DOUBLE);

    JdbcCallableTask interestTask =
        JdbcCallableTask.builder()
            .dataSource(dataSource)
            .call(CALL_CALCULATE_INTEREST)
            .inParameters(interestCalc)
            .outParameters(outParams)
            .writingOutValuesTo("interest")
            .build();

    // Execute all operations
    WorkflowContext context = new WorkflowContext();
    depositTask1.execute(context);
    log.info("✓ Deposited $200 to Account 1");

    depositTask2.execute(context);
    log.info("✓ Deposited $150 to Account 3");

    interestTask.execute(context);
    @SuppressWarnings("unchecked")
    Map<Integer, Object> interestResult = (Map<Integer, Object>) context.get("interest");
    log.info(
        "✓ Calculated interest for Account 2: ${}",
        String.format("%.2f", (Double) interestResult.get(1)));

    log.info("\nFinal balances:");
    verifyAccountBalance(1, ACCOUNT_1);
    verifyAccountBalance(2, ACCOUNT_2);
    verifyAccountBalance(3, "Account 3");
  }

  /**
   * Example 6: Error handling with stored procedures. Demonstrates proper error handling when
   * calling procedures.
   */
  public void example6ErrorHandling() {
    log.info("\n=== Example 6: Error Handling ===");

    // Try to transfer more money than available
    Map<Integer, Object> inParams = new HashMap<>();
    inParams.put(1, 3); // Account 3 (low balance)
    inParams.put(2, 1); // Transfer to Account 1
    inParams.put(3, 10000.0); // Amount exceeds balance

    JdbcCallableTask task =
        JdbcCallableTask.builder()
            .dataSource(dataSource)
            .call(CALL_TRANSFER_MONEY)
            .inParameters(inParams)
            .build();

    WorkflowContext context = new WorkflowContext();

    try {
      task.execute(context);
      log.warn("Transfer unexpectedly succeeded (should have failed)");
    } catch (Exception e) {
      log.info("Transfer correctly failed with insufficient funds");
      log.info("Error message: {}", e.getMessage());
    }

    // Verify account 3 balance unchanged
    verifyAccountBalance(3, "Account 3 (unchanged)");
  }

  /**
   * Bonus: Complete banking workflow with stored procedures. Demonstrates a real-world scenario
   * using multiple procedures.
   */
  public void exampleBonusCompleteBankingWorkflow() {
    log.info("\n=== Bonus: Complete Banking Workflow ===");

    WorkflowContext context = new WorkflowContext();

    // Step 1: Verify source account has sufficient funds
    log.info("Step 1: Verifying account balances...");
    verifyAccountBalance(1, "Source Account");
    verifyAccountBalance(2, "Destination Account");

    // Step 2: Transfer funds
    log.info("\nStep 2: Transferring $400 from Account 1 to Account 2...");
    Map<Integer, Object> transferParams = new HashMap<>();
    transferParams.put(1, 1);
    transferParams.put(2, 2);
    transferParams.put(3, 400.0);

    JdbcCallableTask transferTask =
        JdbcCallableTask.builder()
            .dataSource(dataSource)
            .call(CALL_TRANSFER_MONEY)
            .inParameters(transferParams)
            .build();

    transferTask.execute(context);
    log.info("✓ Transfer completed");

    // Step 3: Calculate interest earned on destination account
    log.info("\nStep 3: Calculating interest on destination account...");
    Map<Integer, Object> interestParams = new HashMap<>();
    interestParams.put(2, 5400.0); // New balance after transfer
    interestParams.put(3, 2.5); // 2.5% interest rate
    interestParams.put(4, 12); // 12 months

    Map<Integer, Integer> outParams = new HashMap<>();
    outParams.put(1, Types.DOUBLE);

    JdbcCallableTask interestTask =
        JdbcCallableTask.builder()
            .dataSource(dataSource)
            .call(CALL_CALCULATE_INTEREST)
            .inParameters(interestParams)
            .outParameters(outParams)
            .writingOutValuesTo("projectedInterest")
            .build();

    interestTask.execute(context);

    // Step 4: Display summary
    log.info("\nStep 4: Transaction Summary");
    log.info("=====================================");
    verifyAccountBalance(1, "Account 1 (After Transfer)");
    verifyAccountBalance(2, "Account 2 (After Transfer)");

    @SuppressWarnings("unchecked")
    Map<Integer, Object> interest = (Map<Integer, Object>) context.get("projectedInterest");
    Double interestAmount = (Double) interest.get(1);
    log.info("Projected interest (12 months): ${}", String.format("%.2f", interestAmount));

    log.info("\nTransaction history:");
    verifyTransactionHistory();
  }

  // Helper methods
  private void verifyAccountBalance(int accountId, String label) {
    JdbcQueryTask query =
        JdbcQueryTask.builder()
            .dataSource(dataSource)
            .sql("SELECT account_number, balance, account_type FROM accounts WHERE id = ?")
            .params(List.of(accountId))
            .writingResultsTo(RESULT)
            .build();

    WorkflowContext ctx = new WorkflowContext();
    query.execute(ctx);

    @SuppressWarnings("unchecked")
    List<Map<String, Object>> result = (List<Map<String, Object>>) ctx.get(RESULT);
    if (!result.isEmpty()) {
      Map<String, Object> account = result.getFirst();
      log.info(
          "  {}: {} - ${} ({})",
          label,
          account.get("ACCOUNT_NUMBER"),
          account.get("BALANCE"),
          account.get("ACCOUNT_TYPE"));
    }
  }

  private void verifyTransactionHistory() {
    JdbcQueryTask query =
        JdbcQueryTask.builder()
            .dataSource(dataSource)
            .sql(
                "SELECT account_id, amount, transaction_type FROM account_transactions ORDER BY id DESC LIMIT 10")
            .writingResultsTo(RESULT)
            .build();

    WorkflowContext ctx = new WorkflowContext();
    query.execute(ctx);

    @SuppressWarnings("unchecked")
    List<Map<String, Object>> result = (List<Map<String, Object>>) ctx.get(RESULT);
    result.forEach(
        txn ->
            log.info(
                "  Account {}: {} ${}",
                txn.get("ACCOUNT_ID"),
                txn.get("TRANSACTION_TYPE"),
                txn.get("AMOUNT")));
  }

  /** Main method to run all examples. */
  public static void main(String[] args) throws SQLException {
    JdbcCallableTaskExample example = new JdbcCallableTaskExample();

    example.example1SimpleProcedureWithInParams();
    example.example2FunctionWithReturnValue();
    example.example3ComplexTransferProcedure();
    example.example4DynamicCallable();
    example.example5BatchOperations();
    example.example6ErrorHandling();
    example.exampleBonusCompleteBankingWorkflow();

    log.info("\n=== All examples completed successfully! ===");
  }
}
